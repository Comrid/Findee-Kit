<!DOCTYPE html>
<!-- HTML5 문서 타입 선언 - 웹 브라우저에게 이 문서가 HTML5임을 알려줌 -->
<html lang="ko">
<!-- HTML 문서의 시작 태그, lang="ko"는 한국어 문서임을 명시 -->
<head>
    <!-- head 태그: 웹페이지의 메타데이터(브라우저에 직접 표시되지 않는 정보)를 포함 -->
    <meta charset="UTF-8">
    <!-- 문자 인코딩을 UTF-8로 설정 - 한글과 다양한 문자를 올바르게 표시 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 반응형 웹을 위한 뷰포트 설정 - 모바일에서도 올바른 크기로 표시 -->
    <title>Pathfinder Motor Control Dashboard</title>
    <!-- 브라우저 탭에 표시될 제목 -->

    <style>
        /* CSS 시작 - 웹페이지의 디자인과 레이아웃을 담당하는 스타일시트 */

        /* Google Fonts에서 Inter 폰트를 가져와서 사용 - 웹페이지 전체의 글꼴 통일 */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        /* 모든 HTML 요소(*는 전체 선택자)의 기본 스타일 초기화 */
        * {
            margin: 0;           /* 외부 여백 제거 */
            padding: 0;          /* 내부 여백 제거 */
            box-sizing: border-box;  /* 요소 크기 계산 방식 통일 */
        }

        /* body 태그: 웹페이지 전체 배경과 기본 설정 */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;  /* 글꼴 지정 */
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);  /* 그라데이션 배경 */
            min-height: 100vh;   /* 최소 높이를 화면 전체로 설정 */
            color: #fff;         /* 글자색을 흰색으로 설정 */
            overflow: hidden;    /* 스크롤바 숨김 */
            user-select: none;   /* 텍스트 선택 방지 */
        }

        /* 메인 컨테이너: 전체 레이아웃을 CSS Grid로 구성 */
        .container {
            display: grid;  /* CSS Grid 레이아웃 사용 */
            /* 2개 열: 첫 번째는 가변(1fr), 두 번째는 고정 350px */
            grid-template-columns: 1fr 350px;
            /* 3개 행: 헤더 60px, 메인 가변(1fr), 푸터 80px */
            grid-template-rows: 60px 1fr 80px;
            /* 각 영역에 이름 부여 - 나중에 grid-area로 배치 */
            grid-template-areas:
                "header header"    /* 헤더는 전체 폭 사용 */
                "camera controls"  /* 메인은 카메라와 컨트롤로 분할 */
                "footer footer";   /* 푸터는 전체 폭 사용 */
            height: 100vh;  /* 화면 전체 높이 */
            gap: 15px;      /* 각 영역 사이의 간격 */
            padding: 15px;  /* 컨테이너 내부 여백 */
        }

        /* 헤더 영역: 제목과 상태 정보 표시 */
        .header {
            grid-area: header;  /* Grid 영역 이름으로 위치 지정 */
            background: rgba(255, 255, 255, 0.1);  /* 반투명 흰색 배경 */
            backdrop-filter: blur(10px);  /* 배경 블러 효과 */
            border-radius: 15px;  /* 모서리 둥글게 */
            display: flex;        /* Flexbox로 내부 요소 배치 */
            align-items: center;  /* 세로 가운데 정렬 */
            justify-content: space-between;  /* 양 끝 정렬 */
            padding: 0 25px;      /* 좌우 여백 */
            border: 1px solid rgba(255, 255, 255, 0.2);  /* 연한 테두리 */
        }

        /* 헤더의 제목(h1 태그) 스타일 */
        .header h1 {
            font-size: 24px;   /* 글자 크기 */
            font-weight: 600;  /* 글자 굵기 */
            color: #fff;       /* 글자색 흰색 */
        }

        /* 상태 정보를 담는 컨테이너 */
        .status-info {
            display: flex;     /* 가로로 나열 */
            gap: 20px;         /* 각 항목 사이 간격 */
            align-items: center;  /* 세로 가운데 정렬 */
        }

        /* 각각의 상태 정보 항목 */
        .status-item {
            display: flex;     /* 가로로 나열 */
            align-items: center;  /* 세로 가운데 정렬 */
            gap: 8px;          /* 아이콘과 텍스트 사이 간격 */
            font-size: 14px;   /* 글자 크기 */
        }

        /* 연결 상태를 나타내는 점 */
        .status-dot {
            width: 8px;        /* 너비 */
            height: 8px;       /* 높이 */
            border-radius: 50%;  /* 원형으로 만들기 */
            background: #4ade80;  /* 초록색 배경 */
            animation: pulse 2s infinite;  /* 깜빡이는 애니메이션 */
        }

        /* 깜빡이는 애니메이션 정의 */
        @keyframes pulse {
            0%, 100% { opacity: 1; }    /* 시작과 끝: 완전 불투명 */
            50% { opacity: 0.5; }       /* 중간: 반투명 */
        }

        /* 카메라 영역 컨테이너 */
        .camera-container {
            grid-area: camera;  /* Grid 영역 배치 */
            background: rgba(0, 0, 0, 0.4);  /* 반투명 검은색 배경 */
            backdrop-filter: blur(10px);     /* 배경 블러 효과 */
            border-radius: 15px;             /* 모서리 둥글게 */
            overflow: hidden;                /* 내용이 넘치면 숨김 */
            position: relative;              /* 자식 요소의 절대 위치 기준점 */
            border: 1px solid rgba(255, 255, 255, 0.2);  /* 연한 테두리 */
        }

        /* 카메라 피드 이미지 */
        .camera-feed {
            width: 100%;      /* 가로 전체 */
            height: 100%;     /* 세로 전체 */
            object-fit: cover;  /* 비율 유지하며 영역 채우기 */
            background: #1a1a1a;  /* 기본 배경색 */
        }

        /* 카메라가 연결되지 않았을 때 표시할 오버레이 */
        .camera-overlay {
            position: absolute;  /* 절대 위치 - camera-container 기준 */
            top: 0;             /* 위쪽 끝에 배치 */
            left: 0;            /* 왼쪽 끝에 배치 */
            right: 0;           /* 오른쪽 끝에 배치 */
            bottom: 0;          /* 아래쪽 끝에 배치 */
            background: rgba(0, 0, 0, 0.5);  /* 반투명 검은색 배경 */
            display: flex;                   /* Flexbox 레이아웃 */
            align-items: center;             /* 세로 가운데 정렬 */
            justify-content: center;         /* 가로 가운데 정렬 */
            flex-direction: column;          /* 세로 방향으로 배치 */
            gap: 15px;                       /* 각 요소 사이 간격 */
        }

        /* 카메라 아이콘 */
        .camera-icon {
            width: 60px;       /* 너비 */
            height: 60px;      /* 높이 */
            background: rgba(255, 255, 255, 0.2);  /* 반투명 흰색 배경 */
            border-radius: 50%;  /* 원형 */
            display: flex;       /* Flexbox */
            align-items: center; /* 세로 가운데 정렬 */
            justify-content: center;  /* 가로 가운데 정렬 */
            font-size: 24px;     /* 아이콘 크기 */
        }

        /* 컨트롤 패널: 로봇 조작 버튼들이 있는 영역 */
        .controls-panel {
            grid-area: controls;  /* Grid 영역 배치 */
            background: rgba(255, 255, 255, 0.1);  /* 반투명 흰색 배경 */
            backdrop-filter: blur(10px);            /* 배경 블러 효과 */
            border-radius: 15px;                    /* 모서리 둥글게 */
            padding: 25px;                          /* 내부 여백 */
            border: 1px solid rgba(255, 255, 255, 0.2);  /* 연한 테두리 */
            display: flex;                          /* Flexbox 레이아웃 */
            flex-direction: column;                 /* 세로 방향으로 배치 */
            gap: 25px;                              /* 각 섹션 사이 간격 */
        }

        /* 컨트롤 패널 제목 */
        .controls-title {
            font-size: 18px;     /* 글자 크기 */
            font-weight: 600;    /* 글자 굵기 */
            text-align: center;  /* 가운데 정렬 */
            margin-bottom: 10px; /* 아래쪽 여백 */
        }

        /* 방향 조작 패드: 9개 버튼을 3x3 격자로 배치 */
        .direction-pad {
            display: grid;                    /* CSS Grid 사용 */
            grid-template-columns: repeat(3, 1fr);  /* 3개 열, 동일한 크기 */
            grid-template-rows: repeat(3, 1fr);     /* 3개 행, 동일한 크기 */
            gap: 8px;                         /* 버튼 사이 간격 */
            max-width: 240px;                 /* 최대 너비 제한 */
            margin: 0 auto;                   /* 가운데 정렬 */
        }

        /* 방향 버튼의 기본 스타일 */
        .direction-btn {
            width: 70px;         /* 너비 */
            height: 70px;        /* 높이 */
            border: none;        /* 기본 테두리 제거 */
            border-radius: 12px; /* 모서리 둥글게 */
            background: rgba(255, 255, 255, 0.2);  /* 반투명 흰색 배경 */
            color: #fff;         /* 글자색 흰색 */
            font-size: 20px;     /* 글자(아이콘) 크기 */
            cursor: pointer;     /* 마우스 커서를 손가락 모양으로 */
            transition: all 0.2s ease;  /* 모든 속성 변화에 0.2초 애니메이션 */
            display: flex;       /* Flexbox */
            align-items: center; /* 세로 가운데 정렬 */
            justify-content: center;  /* 가로 가운데 정렬 */
            position: relative;  /* 상대 위치 */
            border: 2px solid transparent;  /* 투명한 테두리 (나중에 활성화시 색상 변경) */
        }

        /* 마우스를 올렸을 때 효과 */
        .direction-btn:hover {
            background: rgba(255, 255, 255, 0.3);  /* 배경색 더 밝게 */
            transform: scale(1.05);  /* 크기 5% 확대 */
        }

        /* 버튼을 누르고 있을 때 또는 활성화된 상태 */
        .direction-btn:active,
        .direction-btn.active {
            background: rgba(74, 222, 128, 0.6);  /* 초록색 배경 */
            border-color: #4ade80;  /* 초록색 테두리 */
            transform: scale(0.95); /* 크기 5% 축소 (눌린 느낌) */
        }

        /* 비활성화된 버튼 */
        .direction-btn:disabled {
            opacity: 0.5;        /* 투명도 50% */
            cursor: not-allowed; /* 금지 커서 */
        }

        /* 각 버튼의 그리드 위치 지정 - CSS Grid의 grid-column과 grid-row로 정확한 위치 배치 */
        .btn-forward-left { grid-column: 1; grid-row: 1; }     /* 왼쪽 위 */
        .btn-forward { grid-column: 2; grid-row: 1; }          /* 가운데 위 */
        .btn-forward-right { grid-column: 3; grid-row: 1; }    /* 오른쪽 위 */
        .btn-rotate-left { grid-column: 1; grid-row: 2; }      /* 왼쪽 가운데 */
        .btn-stop { grid-column: 2; grid-row: 2; background: rgba(239, 68, 68, 0.6); }  /* 가운데 - 정지 버튼은 빨간색 */
        .btn-rotate-right { grid-column: 3; grid-row: 2; }     /* 오른쪽 가운데 */
        .btn-backward-left { grid-column: 1; grid-row: 3; }    /* 왼쪽 아래 */
        .btn-backward { grid-column: 2; grid-row: 3; }         /* 가운데 아래 */
        .btn-backward-right { grid-column: 3; grid-row: 3; }   /* 오른쪽 아래 */

        /* 정지 버튼에 마우스를 올렸을 때 */
        .btn-stop:hover {
            background: rgba(239, 68, 68, 0.8);  /* 더 진한 빨간색 */
        }

        /* 회전 버튼들을 180도 회전 (아이콘 방향 조정) */
        .btn-rotate-left,
        .btn-rotate-right {
            transform: rotate(180deg);
        }

        /* 회전 버튼에 마우스를 올렸을 때도 180도 회전 유지 */
        .btn-rotate-left:hover,
        .btn-rotate-right:hover {
            transform: rotate(180deg) scale(1.05);
        }

        /* 회전 버튼을 누를 때도 180도 회전 유지 */
        .btn-rotate-left:active,
        .btn-rotate-left.active,
        .btn-rotate-right:active,
        .btn-rotate-right.active {
            transform: rotate(180deg) scale(0.95);
        }

        /* 속도 조절 섹션 */
        .speed-control {
            text-align: center;  /* 가운데 정렬 */
        }

        /* 속도 조절 라벨 */
        .speed-label {
            font-size: 16px;     /* 글자 크기 */
            font-weight: 500;    /* 글자 굵기 */
            margin-bottom: 15px; /* 아래쪽 여백 */
            display: block;      /* 블록 요소로 표시 */
        }

        /* 속도 슬라이더 */
        .speed-slider {
            width: 100%;         /* 가로 전체 */
            height: 8px;         /* 높이 */
            border-radius: 4px;  /* 모서리 둥글게 */
            background: rgba(255, 255, 255, 0.2);  /* 반투명 흰색 배경 */
            outline: none;       /* 포커스 테두리 제거 */
            appearance: none;    /* 기본 스타일 제거 */
            cursor: pointer;     /* 포인터 커서 */
        }

        /* 웹킷 브라우저(Chrome, Safari)용 슬라이더 썸 */
        .speed-slider::-webkit-slider-thumb {
            appearance: none;    /* 기본 스타일 제거 */
            width: 24px;         /* 너비 */
            height: 24px;        /* 높이 */
            border-radius: 50%;  /* 원형 */
            background: #4ade80; /* 초록색 배경 */
            cursor: pointer;     /* 포인터 커서 */
            border: 3px solid #fff;  /* 흰색 테두리 */
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);  /* 그림자 효과 */
        }

        /* 파이어폭스용 슬라이더 썸 */
        .speed-slider::-moz-range-thumb {
            width: 24px;         /* 너비 */
            height: 24px;        /* 높이 */
            border-radius: 50%;  /* 원형 */
            background: #4ade80; /* 초록색 배경 */
            cursor: pointer;     /* 포인터 커서 */
            border: 3px solid #fff;  /* 흰색 테두리 */
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);  /* 그림자 효과 */
        }

        /* 현재 속도 값 표시 */
        .speed-value {
            margin-top: 10px;    /* 위쪽 여백 */
            font-size: 18px;     /* 글자 크기 */
            font-weight: 600;    /* 글자 굵기 */
            color: #4ade80;      /* 초록색 글자 */
        }

        /* 속도 범위 표시 (최소~최대) */
        .speed-range {
            display: flex;               /* Flexbox */
            justify-content: space-between;  /* 양 끝 정렬 */
            margin-top: 5px;             /* 위쪽 여백 */
            font-size: 12px;             /* 글자 크기 */
            color: rgba(255, 255, 255, 0.7);  /* 연한 흰색 글자 */
        }

        /* 로그 패널: 명령어와 상태 메시지를 표시하는 영역 */
        .log-panel {
            flex: 1;              /* 남은 공간 모두 사용 */
            display: flex;        /* Flexbox */
            flex-direction: column;  /* 세로 방향 배치 */
            min-height: 0;        /* 최소 높이 제한 */
        }

        /* 로그 패널 헤더 */
        .log-header {
            display: flex;        /* Flexbox */
            justify-content: space-between;  /* 양 끝 정렬 */
            align-items: center;  /* 세로 가운데 정렬 */
            margin-bottom: 10px;  /* 아래쪽 여백 */
        }

        /* 로그 헤더 제목 */
        .log-header h4 {
            font-size: 16px;   /* 글자 크기 */
            font-weight: 500;  /* 글자 굵기 */
            margin: 0;         /* 기본 여백 제거 */
        }

        /* 로그 지우기 버튼 */
        .log-clear-btn {
            background: rgba(239, 68, 68, 0.6);  /* 빨간색 배경 */
            border: none;        /* 테두리 제거 */
            color: #fff;         /* 흰색 글자 */
            padding: 4px 12px;   /* 내부 여백 */
            border-radius: 6px;  /* 모서리 둥글게 */
            font-size: 12px;     /* 글자 크기 */
            cursor: pointer;     /* 포인터 커서 */
            transition: all 0.2s ease;  /* 애니메이션 */
        }

        /* 로그 지우기 버튼에 마우스를 올렸을 때 */
        .log-clear-btn:hover {
            background: rgba(239, 68, 68, 0.8);  /* 더 진한 빨간색 */
        }

        /* 로그 내용 영역 */
        .log-content {
            background: rgba(0, 0, 0, 0.3);  /* 반투명 검은색 배경 */
            border-radius: 8px;              /* 모서리 둥글게 */
            padding: 12px;                   /* 내부 여백 */
            flex: 1;                         /* 남은 공간 모두 사용 */
            overflow-y: auto;                /* 세로 스크롤 허용 */
            max-height: 610px;               /* 최대 높이 제한 */
            min-height: 600px;               /* 최소 높이 제한 */
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;  /* 고정폭 글꼴 */
            font-size: 12px;                 /* 글자 크기 */
            line-height: 1.4;                /* 줄 간격 */
        }

        /* 개별 로그 항목 */
        .log-item {
            margin-bottom: 6px;   /* 아래쪽 여백 */
            padding: 4px 8px;     /* 내부 여백 */
            border-radius: 4px;   /* 모서리 둥글게 */
            word-wrap: break-word;  /* 긴 단어 줄바꿈 */
        }

        /* 시스템 메시지 스타일 */
        .log-item.system {
            background: rgba(59, 130, 246, 0.2);  /* 파란색 배경 */
            border-left: 3px solid #3b82f6;       /* 파란색 왼쪽 테두리 */
        }

        /* 명령어 메시지 스타일 */
        .log-item.command {
            background: rgba(34, 197, 94, 0.2);   /* 초록색 배경 */
            border-left: 3px solid #22c55e;       /* 초록색 왼쪽 테두리 */
        }

        /* 경고 메시지 스타일 */
        .log-item.warning {
            background: rgba(245, 158, 11, 0.2);  /* 노란색 배경 */
            border-left: 3px solid #f59e0b;       /* 노란색 왼쪽 테두리 */
        }

        /* 에러 메시지 스타일 */
        .log-item.error {
            background: rgba(239, 68, 68, 0.2);   /* 빨간색 배경 */
            border-left: 3px solid #ef4444;       /* 빨간색 왼쪽 테두리 */
        }

        /* 로그 타임스탬프 */
        .log-timestamp {
            color: rgba(255, 255, 255, 0.5);  /* 연한 흰색 글자 */
            font-size: 10px;                  /* 작은 글자 크기 */
        }

        /* 푸터 영역 */
        .footer {
            grid-area: footer;    /* Grid 영역 배치 */
            background: rgba(255, 255, 255, 0.1);  /* 반투명 흰색 배경 */
            backdrop-filter: blur(10px);            /* 배경 블러 효과 */
            border-radius: 15px;                    /* 모서리 둥글게 */
            display: flex;                          /* Flexbox */
            align-items: center;                    /* 세로 가운데 정렬 */
            justify-content: center;                /* 가로 가운데 정렬 */
            padding: 0 25px;                        /* 좌우 여백 */
            border: 1px solid rgba(255, 255, 255, 0.2);  /* 연한 테두리 */
        }

        /* 키보드 단축키 설명 */
        .keyboard-hints {
            display: flex;        /* Flexbox */
            gap: 30px;            /* 각 항목 사이 간격 */
            flex-wrap: wrap;      /* 줄바꿈 허용 */
            justify-content: center;  /* 가운데 정렬 */
        }

        /* 각 단축키 설명 항목 */
        .hint-item {
            display: flex;        /* Flexbox */
            align-items: center;  /* 세로 가운데 정렬 */
            gap: 8px;             /* 키와 설명 사이 간격 */
            font-size: 14px;      /* 글자 크기 */
        }

        /* 키보드 키 표시 스타일 */
        .key {
            background: rgba(255, 255, 255, 0.2);  /* 반투명 흰색 배경 */
            padding: 4px 8px;                      /* 내부 여백 */
            border-radius: 6px;                    /* 모서리 둥글게 */
            font-family: monospace;                /* 고정폭 글꼴 */
            font-size: 12px;                       /* 글자 크기 */
            border: 1px solid rgba(255, 255, 255, 0.3);  /* 연한 테두리 */
        }

        /* 연결 상태 표시 */
        .connection-status {
            position: absolute;   /* 절대 위치 */
            top: 15px;           /* 위에서 15px */
            left: 15px;          /* 왼쪽에서 15px */
            background: rgba(0, 0, 0, 0.7);  /* 반투명 검은색 배경 */
            padding: 8px 12px;   /* 내부 여백 */
            border-radius: 8px;  /* 모서리 둥글게 */
            font-size: 12px;     /* 글자 크기 */
            z-index: 10;         /* 다른 요소보다 위에 표시 */
        }

        /* 반응형 디자인: 768px 이하 화면(태블릿, 모바일)에서 적용 */
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;  /* 1개 열로 변경 */
                grid-template-rows: 60px 1fr 300px 80px;  /* 4개 행으로 변경 */
                grid-template-areas:
                    "header"    /* 헤더 */
                    "camera"    /* 카메라 */
                    "controls"  /* 컨트롤 */
                    "footer";   /* 푸터 */
            }

            /* 모바일에서 방향 패드 크기 조정 */
            .direction-pad {
                max-width: 200px;  /* 최대 너비 축소 */
            }

            /* 모바일에서 방향 버튼 크기 조정 */
            .direction-btn {
                width: 60px;      /* 너비 축소 */
                height: 60px;     /* 높이 축소 */
                font-size: 18px;  /* 글자 크기 축소 */
            }
        }
    </style>
    <!-- Socket.IO 클라이언트 라이브러리 로드 - 서버와 실시간 통신을 위한 JavaScript 라이브러리 -->
    <script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>
</head>

<body>
    <!-- HTML 본문 시작 - 사용자에게 실제로 보여지는 내용 -->
    <div class="container">
        <!-- 메인 컨테이너: CSS Grid로 레이아웃이 구성된 최상위 요소 -->

        <!-- 헤더 섹션: 제목과 상태 정보 표시 -->
        <header class="header">
            <h1>🤖 Robot Control Dashboard</h1>
            <!-- 로봇 제어 대시보드 제목 -->
            <div class="status-info">
                <!-- 상태 정보를 묶는 컨테이너 -->
                <div class="status-item">
                    <!-- 연결 상태 표시 -->
                    <div class="status-dot"></div>
                    <!-- 깜빡이는 초록색 점 -->
                    <span>Connected</span>
                    <!-- 연결됨 텍스트 -->
                </div>
                <div class="status-item">
                    <!-- WiFi 신호 강도 표시 -->
                    <span>📶 WiFi: 85%</span>
                </div>
                <div class="status-item">
                    <!-- 배터리 잔량 표시 -->
                    <span>🔋 Battery: 78%</span>
                </div>
            </div>
        </header>

        <!-- 카메라 피드 섹션: 로봇의 카메라 영상을 표시 -->
        <div class="camera-container">
            <div class="connection-status">📹 Camera Feed</div>
            <!-- 카메라 상태 표시 라벨 -->

            <!-- 카메라가 연결되지 않았을 때 보여줄 오버레이 -->
            <div class="camera-overlay">
                <div class="camera-icon">📹</div>
                <!-- 카메라 아이콘 -->
                <div>Camera Feed</div>
                <!-- 제목 -->
                <div style="font-size: 12px; opacity: 0.7;">실시간 영상이 여기에 표시됩니다</div>
                <!-- 설명 텍스트 -->
            </div>
        </div>

        <!-- 컨트롤 패널: 로봇 조작을 위한 버튼들과 설정 -->
        <div class="controls-panel">
            <h3 class="controls-title">Motor Control</h3>
            <!-- 컨트롤 패널 제목 -->

            <!-- 방향 조작 패드: 9개 버튼으로 구성된 3x3 격자 -->
            <div class="direction-pad">
                <!-- 첫 번째 줄: 전진 관련 버튼들 -->
                <button class="direction-btn btn-forward-left" data-direction="forward-left" title="전진+좌회전">↖</button>
                <button class="direction-btn btn-forward" data-direction="forward" title="전진">↑</button>
                <button class="direction-btn btn-forward-right" data-direction="forward-right" title="전진+우회전">↗</button>

                <!-- 두 번째 줄: 회전과 정지 버튼들 -->
                <button class="direction-btn btn-rotate-left" data-direction="rotate-left" title="제자리 좌회전">↺</button>
                <button class="direction-btn btn-stop" data-direction="stop" title="정지">⏹</button>
                <button class="direction-btn btn-rotate-right" data-direction="rotate-right" title="제자리 우회전">↻</button>

                <!-- 세 번째 줄: 후진 관련 버튼들 -->
                <button class="direction-btn btn-backward-left" data-direction="backward-left" title="후진+좌회전">↙</button>
                <button class="direction-btn btn-backward" data-direction="backward" title="후진">↓</button>
                <button class="direction-btn btn-backward-right" data-direction="backward-right" title="후진+우회전">↘</button>
            </div>
            <!-- data-direction 속성: JavaScript에서 어떤 버튼인지 구분하기 위한 식별자 -->
            <!-- title 속성: 마우스를 올렸을 때 표시되는 툴팁 -->

            <!-- 속도 조절 섹션 -->
            <div class="speed-control">
                <label class="speed-label">속도 조절</label>
                <!-- 슬라이더 라벨 -->
                <input type="range" class="speed-slider" id="speedSlider" min="20" max="100" value="60">
                <!-- 범위 슬라이더: 최소 20%, 최대 100%, 기본값 60% -->
                <div class="speed-value" id="speedValue">60%</div>
                <!-- 현재 속도 값을 표시하는 영역 -->
                <div class="speed-range">
                    <!-- 최소/최대값 표시 -->
                    <span>20%</span>
                    <span>100%</span>
                </div>
            </div>

            <!-- 로그 패널: 시스템 메시지와 명령어 기록 표시 -->
            <div class="log-panel">
                <div class="log-header">
                    <!-- 로그 패널 헤더 -->
                    <h4>Activity Log</h4>
                    <!-- 제목 -->
                    <button class="log-clear-btn" id="clearLogBtn">Clear</button>
                    <!-- 로그 지우기 버튼 -->
                </div>
                <div class="log-content" id="logContent">
                    <!-- 로그 내용이 표시되는 영역 - JavaScript에서 동적으로 내용 추가 -->
                    <div class="log-item system">🚀 Robot Control Dashboard initialized</div>
                    <!-- 초기 시스템 메시지 -->
                </div>
            </div>
        </div>

        <!-- 푸터: 키보드 단축키 설명 -->
        <footer class="footer">
            <div class="keyboard-hints">
                <!-- 키보드 단축키 설명들을 묶는 컨테이너 -->
                <div class="hint-item">
                    <span class="key">↑↓←→</span>
                    <span>기본 조작</span>
                </div>
                <div class="hint-item">
                    <span class="key">↑+←</span><span class="key">↑+→</span>
                    <span>전진 대각선</span>
                </div>
                <div class="hint-item">
                    <span class="key">↓+←</span><span class="key">↓+→</span>
                    <span>후진 대각선</span>
                </div>
                <div class="hint-item">
                    <span class="key">Space</span>
                    <span>정지</span>
                </div>
                <div class="hint-item">
                    <span class="key">+/-</span>
                    <span>속도 조절</span>
                </div>
            </div>
        </footer>
    </div>

    <!-- JavaScript 시작 - 웹페이지의 동작과 상호작용을 담당 -->
    <script>
        // 클래스 정의: 로봇 컨트롤러의 모든 기능을 포함하는 객체
        class RobotController {
            // 생성자: 클래스가 생성될 때 초기값들을 설정
            constructor() {
                this.currentSpeed = 60;           // 현재 속도 (기본값 60%)
                this.activeButtons = new Set();   // 현재 활성화된 버튼들을 저장하는 Set (중복 제거)
                this.pressedKeys = new Set();     // 현재 눌린 키들을 저장하는 Set
                this.keyPressOrder = [];          // 키를 누른 순서를 기록하는 배열
                this.isConnected = false;         // 로봇 연결 상태
                this.speedAdjustInterval = null;  // 속도 조절 타이머 ID
                this.speedAdjustDelay = 30;       // 연속 조절 간격 (밀리초)
                // 속도 조절 가속도 설정 객체
                this.speedAdjustAcceleration = {
                    initialDelay: 100,     // 초기 간격
                    minDelay: 20,          // 최소 간격
                    acceleration: 0.9,     // 가속 비율
                    currentDelay: 100      // 현재 간격
                }

                this.init();  // 초기화 함수 호출
            }

            // 초기화 함수: 모든 설정을 순서대로 실행
            init() {
                this.setupEventListeners();    // 이벤트 리스너 설정
                this.setupSpeedControl();      // 속도 조절 설정
                this.setupSocketConnection();  // 소켓 연결 설정
                this.setupLogPanel();          // 로그 패널 설정

                // 1초 후 연결 시뮬레이션 (실제로는 서버 연결 후 상태 변경)
                setTimeout(() => {
                    this.isConnected = true;
                    this.addLog('🤖 Robot connected successfully!', 'system');
                }, 1000);
            }

            // 이벤트 리스너 설정: 마우스, 터치, 키보드 이벤트 처리
            setupEventListeners() {
                // 모든 방향 버튼에 대해 이벤트 리스너 등록
                document.querySelectorAll('.direction-btn').forEach(btn => {
                    // 마우스 이벤트
                    btn.addEventListener('mousedown', (e) => this.handleButtonPress(e.target));
                    btn.addEventListener('mouseup', (e) => this.handleButtonRelease(e.target));
                    btn.addEventListener('mouseleave', (e) => this.handleButtonRelease(e.target));

                    // 터치 이벤트 (모바일 지원)
                    btn.addEventListener('touchstart', (e) => {
                        e.preventDefault();  // 기본 터치 동작 방지
                        this.handleButtonPress(e.target);
                    });
                    btn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.handleButtonRelease(e.target);
                    });
                });

                // 키보드 이벤트 (전체 문서에 등록)
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
                document.addEventListener('keyup', (e) => this.handleKeyUp(e));

                // 포커스 유지 (키보드 이벤트가 제대로 작동하도록)
                document.addEventListener('click', () => document.body.focus());
                document.body.tabIndex = 0;  // body에 포커스 가능하도록 설정
            }

            // 속도 조절 슬라이더 설정
            setupSpeedControl() {
                const speedSlider = document.getElementById('speedSlider');
                const speedValue = document.getElementById('speedValue');

                // 슬라이더 값이 변경될 때 실행되는 이벤트
                speedSlider.addEventListener('input', (e) => {
                    this.currentSpeed = parseInt(e.target.value);  // 새로운 속도값 저장
                    speedValue.textContent = `${this.currentSpeed}%`;  // 화면에 표시

                    // 서버에 속도 변경 알림 (Socket.IO 사용)
                    if (this.socket) {
                        this.socket.emit('set_speed', { speed: this.currentSpeed });
                    }

                    // 현재 이동 중이면 새로운 속도로 명령 업데이트
                    if (this.activeButtons.size > 0) {
                        this.updateMotorCommand();
                    }
                });
            }

            // Socket.IO 연결 설정: 서버와의 실시간 통신
            // Socket.IO는 웹브라우저와 서버 간의 실시간 양방향 통신을 가능하게 하는 라이브러리
            setupSocketConnection() {
                // Socket.IO 연결 생성 - io()는 현재 페이지의 서버에 자동으로 연결
                this.socket = io();

                // 연결 성공 이벤트 - 서버와 연결이 성공했을 때 실행되는 콜백 함수
                this.socket.on('connect', () => {
                    // addLog 메소드를 호출하여 로그 패널에 연결 성공 메시지 표시
                    this.addLog('🔌 Socket connected to server', 'system');
                    // 연결 상태를 true로 설정 (다른 메소드들이 이 값을 확인하여 명령 전송 여부 결정)
                    this.isConnected = true;
                });

                // 연결 끊김 이벤트 - 서버와 연결이 끊어졌을 때 실행되는 콜백 함수
                this.socket.on('disconnect', () => {
                    // 연결 끊김 메시지를 경고 타입으로 로그에 표시
                    this.addLog('🔌 Socket disconnected from server', 'warning');
                    // 연결 상태를 false로 설정 (명령 전송을 차단하기 위함)
                    this.isConnected = false;
                });

                // 서버에서 보내는 각종 이벤트들 처리
                // 각 .on() 메소드는 서버에서 특정 이벤트가 발생했을 때 실행될 함수를 등록

                // 연결 상태 업데이트 - 서버에서 연결 상태 변경을 알려올 때
                this.socket.on('connection_status', (data) => {
                    // 서버에서 받은 데이터로 연결 상태 업데이트
                    this.isConnected = data.connected;
                    // 연결 상태에 따라 다른 타입의 로그 메시지 표시
                    this.addLog(`📡 ${data.message}`, data.connected ? 'system' : 'warning');
                });

                // 로봇 상태 정보 수신 - 서버에서 로봇의 현재 상태를 보내올 때
                this.socket.on('robot_status', (data) => {
                    // 서버에서 받은 속도 값으로 현재 속도 업데이트
                    this.currentSpeed = data.speed;
                    // HTML의 속도 슬라이더 값을 서버에서 받은 값으로 동기화
                    document.getElementById('speedSlider').value = data.speed;
                    // HTML의 속도 표시 텍스트도 함께 업데이트
                    document.getElementById('speedValue').textContent = `${data.speed}%`;
                    // 로봇 상태 정보를 로그에 표시
                    this.addLog(`🤖 Robot status: ${data.direction} at ${data.speed}%`, 'system');
                });

                // 모터 피드백 수신 - 모터 명령 실행 결과를 서버에서 알려올 때
                this.socket.on('motor_feedback', (data) => {
                    // 명령 성공/실패에 따라 다른 메시지와 타입으로 로그 표시
                    if (data.success) {
                        this.addLog(`✅ Motor: ${data.direction} (${data.speed}%)`, 'command');
                    } else {
                        this.addLog(`❌ Motor command failed: ${data.direction}`, 'error');
                    }
                });

                // 속도 업데이트 확인 - 서버에서 속도 변경이 완료되었음을 알려올 때
                this.socket.on('speed_updated', (data) => {
                    this.addLog(`⚡ Speed updated: ${data.speed}%`, 'system');
                });

                // 거리 센서 데이터 수신 - 서버에서 거리 측정 값을 보내올 때
                this.socket.on('distance_update', (data) => {
                    // 거리 값을 소수점 1자리까지 표시하여 로그에 추가
                    this.addLog(`📏 Distance: ${data.distance.toFixed(1)}cm`, 'system');
                });

                // 카메라 프레임 수신 - 서버에서 카메라 영상 데이터를 보내올 때
                this.socket.on('camera_frame', (data) => {
                    // 카메라 프레임 업데이트
                    // HTML에서 카메라 관련 요소들을 찾기
                    const cameraFeed = document.querySelector('.camera-feed');
                    const cameraOverlay = document.querySelector('.camera-overlay');

                    // 카메라 피드 요소가 존재하고 이미지 데이터가 있을 때
                    if (cameraFeed && data.image) {
                        // 처음 카메라 프레임이 올 때만 실행 (src 속성이 없을 때)
                        if (!cameraFeed.src) {
                            // 처음 카메라 프레임이 오면 overlay 숨기기
                            // overlay는 "카메라 연결 중..." 같은 메시지를 표시하는 요소
                            if (cameraOverlay) cameraOverlay.style.display = 'none';

                            // img 태그 생성하여 카메라 영상을 표시할 준비
                            const img = document.createElement('img');
                            img.className = 'camera-feed';  // CSS 클래스 적용
                            img.style.width = '100%';       // 부모 요소 너비에 맞춤
                            img.style.height = '100%';      // 부모 요소 높이에 맞춤
                            img.style.objectFit = 'cover';  // 비율 유지하며 영역 채우기
                            // 기존 카메라 피드 요소의 부모에 새 img 요소 추가
                            cameraFeed.parentNode.appendChild(img);
                        }

                        // 실제 카메라 이미지를 표시할 img 요소 찾기
                        const img = document.querySelector('img.camera-feed');
                        if (img) {
                            // Base64로 인코딩된 이미지 데이터를 img의 src에 설정
                            // 서버에서 받은 이미지 데이터를 브라우저가 표시할 수 있는 형태로 변환
                            img.src = `data:image/jpeg;base64,${data.image}`;
                        }
                    }
                });

                // 비상 정지 확인 - 서버에서 비상 정지가 실행되었음을 알려올 때
                this.socket.on('emergency_stop_confirmed', (data) => {
                    this.addLog('🚨 Emergency stop executed!', 'error');
                });

                // Socket 연결 초기화 완료 메시지
                this.addLog('🔌 Socket connection initialized', 'system');
            }

            // 로그 패널 설정 - 화면의 로그 영역 관련 기능 초기화
            setupLogPanel() {
                // HTML에서 "로그 지우기" 버튼 요소를 찾기
                const clearBtn = document.getElementById('clearLogBtn');
                // 버튼 클릭 시 clearLog 메소드 실행하도록 이벤트 리스너 등록
                clearBtn.addEventListener('click', () => {
                    this.clearLog();  // 아래에 정의된 clearLog 메소드 호출
                });
            }

            // 버튼이 눌렸을 때 처리하는 함수 (마우스 클릭, 터치 시작)
            handleButtonPress(button) {
                // HTML 버튼 요소의 data-direction 속성에서 방향 정보 가져오기
                const direction = button.dataset.direction;
                // 방향 정보가 없거나 이미 활성화된 버튼이면 무시
                if (!direction || this.activeButtons.has(direction)) return;

                // 활성화된 버튼 목록에 추가 (Set 자료구조 사용)
                this.activeButtons.add(direction);
                // CSS 클래스 추가하여 버튼의 시각적 상태 변경 (눌린 상태로 표시)
                button.classList.add('active');
                // 실제 모터 명령을 서버로 전송
                this.sendMotorCommand(direction);

                // 로그에 버튼 누름 동작 기록
                this.addLog(`🎮 Button pressed: ${direction} at ${this.currentSpeed}% speed`, 'command');
            }

            // 버튼이 떼어졌을 때 처리하는 함수 (마우스 릴리즈, 터치 종료)
            handleButtonRelease(button) {
                // HTML 버튼 요소의 data-direction 속성에서 방향 정보 가져오기
                const direction = button.dataset.direction;
                // 방향 정보가 없거나 활성화되지 않은 버튼이면 무시
                if (!direction || !this.activeButtons.has(direction)) return;

                // 활성화된 버튼 목록에서 제거
                this.activeButtons.delete(direction);
                // CSS 클래스 제거하여 버튼의 시각적 상태 원복 (일반 상태로 표시)
                button.classList.remove('active');

                // 활성화된 버튼이 없으면 정지 명령, 있으면 남은 버튼들로 명령 업데이트
                if (this.activeButtons.size === 0) {
                    this.sendMotorCommand('stop');  // 모든 버튼이 떼어지면 정지
                } else {
                    this.updateMotorCommand();      // 다른 버튼이 아직 눌려있으면 해당 명령 계속
                }

                // 로그에 버튼 떼기 동작 기록
                this.addLog(`🎮 Button released: ${direction}`, 'command');
            }

            // 키보드 키가 눌렸을 때 처리하는 함수
            handleKeyDown(e) {
                // 속도 조절 키 처리 (+, =, - 키)
                if (e.key === '+' || e.key === '=') {
                    this.startSpeedAdjustment(1);   // 속도 증가 시작
                    e.preventDefault();             // 브라우저 기본 동작 방지
                    return;
                } else if (e.key === '-') {
                    this.startSpeedAdjustment(-1);  // 속도 감소 시작
                    e.preventDefault();             // 브라우저 기본 동작 방지
                    return;
                }

                // 허용된 키가 아니면 무시 (화살표키, 스페이스바만 처리)
                if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) return;

                // 이미 눌린 키면 무시 (키 반복 방지)
                if (this.pressedKeys.has(e.code)) return;

                // 눌린 키를 Set에 추가하고 순서 배열에도 추가
                this.pressedKeys.add(e.code);
                this.keyPressOrder.push(e.code);

                // 현재 눌린 키들을 분석하여 방향 결정 및 버튼 동작 실행
                this.updateDirectionFromKeys();
                e.preventDefault();  // 브라우저 기본 동작 방지 (페이지 스크롤 등)
            }

            // 키보드 키가 떼어졌을 때 처리하는 함수
            handleKeyUp(e) {
                // 속도 조절 키를 뗐을 때 연속 조절 중지
                if (e.key === '+' || e.key === '=' || e.key === '-') {
                    this.stopSpeedAdjustment();
                    return;
                }

                // 허용된 키가 아니면 무시
                if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) return;

                // 눌린 키 목록에서 제거 (Set과 배열 모두에서)
                this.pressedKeys.delete(e.code);
                this.keyPressOrder = this.keyPressOrder.filter(key => key !== e.code);

                // 남은 키들을 분석하여 방향 결정 및 버튼 동작 업데이트
                this.updateDirectionFromKeys();
            }

            // 현재 눌린 키들을 분석하여 버튼 동작을 업데이트하는 함수
            updateDirectionFromKeys() {
                // 현재 눌린 키들로부터 새로운 방향 계산
                const newDirection = this.getDirectionFromKeys();
                // 현재 활성화된 방향 (첫 번째 요소만 가져옴 - 한 번에 하나 방향만 처리)
                const currentDirection = Array.from(this.activeButtons)[0] || null;

                // 방향이 바뀌면 이전 버튼 해제
                if (currentDirection && currentDirection !== newDirection) {
                    // HTML에서 이전 방향에 해당하는 버튼 요소 찾기
                    const oldButton = document.querySelector(`[data-direction="${currentDirection}"]`);
                    if (oldButton) this.handleButtonRelease(oldButton);  // 이전 버튼 떼기 동작 실행
                }

                // 새 방향이 있으면 버튼 누르기
                if (newDirection && newDirection !== currentDirection) {
                    // HTML에서 새 방향에 해당하는 버튼 요소 찾기
                    const newButton = document.querySelector(`[data-direction="${newDirection}"]`);
                    if (newButton) this.handleButtonPress(newButton);    // 새 버튼 누르기 동작 실행
                }
            }

            // 현재 눌린 키들을 분석하여 로봇의 이동 방향을 결정하는 함수
            getDirectionFromKeys() {
                // 각 방향키의 눌림 상태 확인
                const up = this.pressedKeys.has('ArrowUp');
                const down = this.pressedKeys.has('ArrowDown');
                const left = this.pressedKeys.has('ArrowLeft');
                const right = this.pressedKeys.has('ArrowRight');
                const stop = this.pressedKeys.has('Space');

                // 스페이스바가 눌리면 무조건 정지
                if (stop) return 'stop';

                // 가장 최근에 눌린 키를 기준으로 우선순위 결정
                const lastKey = this.keyPressOrder[this.keyPressOrder.length - 1];

                // 8방향 조합 (대각선 이동) - 두 키가 동시에 눌린 경우
                if (up && left) {
                    return lastKey === 'ArrowUp' ? 'forward-left' : 'forward-left';
                }
                if (up && right) {
                    return lastKey === 'ArrowUp' ? 'forward-right' : 'forward-right';
                }
                if (down && left) {
                    return lastKey === 'ArrowDown' ? 'backward-left' : 'backward-left';
                }
                if (down && right) {
                    return lastKey === 'ArrowDown' ? 'backward-right' : 'backward-right';
                }

                // 단일 방향 - 마지막에 누른 키 우선
                if (lastKey === 'ArrowUp' && up) return 'forward';
                if (lastKey === 'ArrowDown' && down) return 'backward';
                if (lastKey === 'ArrowLeft' && left) return 'rotate-left';
                if (lastKey === 'ArrowRight' && right) return 'rotate-right';

                // 마지막 키가 없거나 해당하지 않으면 기본 순서로 처리
                if (up) return 'forward';
                if (down) return 'backward';
                if (left) return 'rotate-left';
                if (right) return 'rotate-right';

                return null;  // 아무 키도 눌리지 않은 상태
            }

            // 속도를 지정된 값만큼 조절하는 함수
            adjustSpeed(delta) {
                // 현재 속도에 delta를 더해서 새 속도 계산 (20~100% 범위로 제한)
                const newSpeed = Math.max(20, Math.min(100, this.currentSpeed + delta));
                // HTML 슬라이더의 값을 새 속도로 설정
                document.getElementById('speedSlider').value = newSpeed;
                // 슬라이더의 input 이벤트를 강제로 발생시켜 속도 변경 처리 실행
                document.getElementById('speedSlider').dispatchEvent(new Event('input'));
            }

            // 연속적인 속도 조절을 시작하는 함수 (키를 계속 누르고 있을 때)
            startSpeedAdjustment(delta) {
                // 이미 조절 중이면 중지
                if (this.speedAdjustInterval) {
                    this.stopSpeedAdjustment();
                }

                // 가속도 초기화 (처음에는 천천히, 점점 빨라짐)
                this.speedAdjustAcceleration.currentDelay = this.speedAdjustAcceleration.initialDelay;

                // 즉시 한 번 실행
                this.adjustSpeed(delta);

                // 가속되는 연속 조절 시작
                this.scheduleNextSpeedAdjust(delta);
            }

            // 다음 속도 조절을 예약하는 함수 (가속도 적용)
            scheduleNextSpeedAdjust(delta) {
                // setTimeout을 사용하여 지연 후 다음 조절 실행
                this.speedAdjustInterval = setTimeout(() => {
                    this.adjustSpeed(delta);  // 속도 조절 실행

                    // 간격을 점점 줄여서 가속 (최소 간격까지)
                    this.speedAdjustAcceleration.currentDelay = Math.max(
                        this.speedAdjustAcceleration.minDelay,
                        this.speedAdjustAcceleration.currentDelay * this.speedAdjustAcceleration.acceleration
                    );

                    // 다음 조절 예약 (재귀 호출)
                    this.scheduleNextSpeedAdjust(delta);
                }, this.speedAdjustAcceleration.currentDelay);
            }

            // 연속 속도 조절을 중지하는 함수
            stopSpeedAdjustment() {
                // 예약된 timeout이 있으면 취소
                if (this.speedAdjustInterval) {
                    clearTimeout(this.speedAdjustInterval);
                    this.speedAdjustInterval = null;
                }
                // 가속도 초기화 (다음에 다시 시작할 때를 위해)
                this.speedAdjustAcceleration.currentDelay = this.speedAdjustAcceleration.initialDelay;
            }

            // 현재 활성화된 버튼들을 기반으로 모터 명령을 업데이트하는 함수
            updateMotorCommand() {
                // 활성화된 버튼이 있으면 첫 번째 방향으로 명령 전송
                if (this.activeButtons.size > 0) {
                    const direction = Array.from(this.activeButtons)[0];
                    this.sendMotorCommand(direction);
                }
            }

            // 실제로 서버에 모터 제어 명령을 전송하는 함수
            sendMotorCommand(direction) {
                // 서버와 연결되지 않았으면 경고 메시지만 표시하고 종료
                if (!this.isConnected) {
                    this.addLog('🚫 Robot not connected', 'warning');
                    return;
                }

                // 서버로 보낼 명령 객체 생성
                const command = {
                    direction: direction,        // 이동 방향
                    speed: this.currentSpeed,    // 현재 설정된 속도
                    timestamp: Date.now()        // 명령 생성 시간 (밀리초)
                };

                // Socket.IO로 모터 제어 명령 전송
                if (this.socket) {
                    // 'motor_control' 이벤트로 명령 객체를 서버에 전송
                    this.socket.emit('motor_control', command);
                    // 전송 완료 로그 표시
                    this.addLog(`📡 Sent: ${direction} (${this.currentSpeed}%)`, 'command');
                } else {
                    // socket이 없으면 에러 로그 표시
                    this.addLog('🚫 Socket not available', 'error');
                }

                // 사용자에게 시각적 피드백 제공
                this.showCommandFeedback(direction);
            }

            // 명령 전송 시 시각적 피드백을 제공하는 함수
            showCommandFeedback(direction) {
                // 방향별 표시 이름 정의 (한글 + 이모지)
                const directionNames = {
                    'forward': '⬆️ 전진',
                    'backward': '⬇️ 후진',
                    'forward-left': '↖️ 전진+좌회전',
                    'forward-right': '↗️ 전진+우회전',
                    'backward-left': '↙️ 후진+좌회전',
                    'backward-right': '↘️ 후진+우회전',
                    'rotate-left': '↺ 제자리 좌회전',
                    'rotate-right': '↻ 제자리 우회전',
                    'stop': '⏹️ 정지'
                };

                // 현재는 로그에 표시하지 않음 (너무 많은 메시지로 인한 로그 과부하 방지)
                // 필요시 여기에 추가적인 시각적 피드백 코드 구현 가능
            }

            // 로그 패널에 메시지를 추가하는 함수
            addLog(message, type = 'system') {
                // HTML에서 로그 내용을 표시할 컨테이너 요소 찾기
                const logContent = document.getElementById('logContent');
                // 새로운 로그 아이템을 위한 div 요소 생성
                const logItem = document.createElement('div');
                // CSS 클래스 설정 (기본 + 타입별 스타일 적용)
                logItem.className = `log-item ${type}`;

                // 현재 시간을 시:분:초 형태로 포맷
                const timestamp = new Date().toLocaleTimeString();
                // 로그 아이템의 HTML 내용 설정 (시간 + 메시지)
                logItem.innerHTML = `
                    <span class="log-timestamp">[${timestamp}]</span> ${message}
                `;

                // 로그 컨테이너에 새 로그 아이템 추가
                logContent.appendChild(logItem);

                // 자동 스크롤 (최신 로그가 보이도록) - 스크롤을 맨 아래로 이동
                logContent.scrollTop = logContent.scrollHeight;

                // 로그가 너무 많으면 오래된 것 제거 (최대 100개 유지)
                const logItems = logContent.querySelectorAll('.log-item');
                if (logItems.length > 100) {
                    // 가장 오래된 로그 (첫 번째) 제거
                    logItems[0].remove();
                }
            }

            // 로그 패널의 모든 내용을 지우는 함수
            clearLog() {
                // HTML에서 로그 내용 컨테이너 찾기
                const logContent = document.getElementById('logContent');
                // 모든 내용 제거
                logContent.innerHTML = '';
                // 로그 지움 메시지 추가
                this.addLog('📝 Log cleared', 'system');
            }
        }

        // ===== JavaScript - 앱 초기화 및 전역 이벤트 처리 =====

        // 앱 초기화 - HTML 문서가 모두 로드된 후 실행
        document.addEventListener('DOMContentLoaded', () => {
            // RobotController 클래스의 인스턴스 생성
            const controller = new RobotController();

            // 글로벌 객체로 접근 가능하게 설정 (개발자 도구에서 디버깅 시 유용)
            window.robotController = controller;

            // 0.1초 후 사용법 안내 메시지들을 로그에 표시
            setTimeout(() => {
                controller.addLog('📖 사용법:', 'system');
                controller.addLog('   - 마우스: 버튼 클릭으로 조작', 'system');
                controller.addLog('   - 키보드: 화살표키, Space(정지), +/-(속도)', 'system');
                controller.addLog('   - F1: 거리 모니터링 시작/중지', 'system');
                controller.addLog('   - F2: 카메라 시작/중지', 'system');
            }, 100);

            // 추가 키보드 단축키 처리 (F1, F2 키)
            document.addEventListener('keydown', (e) => {
                // F1 키 - 거리 모니터링 토글
                if (e.key === 'F1') {
                    e.preventDefault();  // 브라우저 기본 동작 방지 (도움말 창 등)
                    // socket 연결이 있을 때만 실행
                    if (controller.socket) {
                        // 현재 거리 모니터링 상태에 따라 시작/중지
                        if (controller.distanceMonitoring) {
                            // 모니터링 중지 명령을 서버에 전송
                            controller.socket.emit('stop_distance_monitoring');
                            controller.distanceMonitoring = false;
                            controller.addLog('📏 Distance monitoring stopped', 'system');
                        } else {
                            // 모니터링 시작 명령을 서버에 전송
                            controller.socket.emit('start_distance_monitoring');
                            controller.distanceMonitoring = true;
                            controller.addLog('📏 Distance monitoring started', 'system');
                        }
                    }
                // F2 키 - 카메라 토글
                } else if (e.key === 'F2') {
                    e.preventDefault();  // 브라우저 기본 동작 방지
                    // socket 연결이 있을 때만 실행
                    if (controller.socket) {
                        // 현재 카메라 상태에 따라 시작/중지
                        if (controller.cameraActive) {
                            // 카메라 중지 명령을 서버에 전송
                            controller.socket.emit('stop_camera');
                            controller.cameraActive = false;
                            controller.addLog('📹 Camera stopped', 'system');
                        } else {
                            // 카메라 시작 명령을 서버에 전송
                            controller.socket.emit('start_camera');
                            controller.cameraActive = true;
                            controller.addLog('📹 Camera started', 'system');
                        }
                    }
                }
            });

            // 거리 모니터링 및 카메라 상태 초기화 (처음에는 비활성 상태)
            controller.distanceMonitoring = false;
            controller.cameraActive = false;
        });

        // 페이지 언로드(닫기/새로고침) 시 정리 작업
        window.addEventListener('beforeunload', () => {
            // robotController가 존재하면 안전하게 정리
            if (window.robotController) {
                // 로봇 정지 명령 전송
                window.robotController.sendMotorCommand('stop');
                // 속도 조절 중지
                window.robotController.stopSpeedAdjustment();
            }
        });

        // ===== 코드 구조 및 상호작용 설명 =====
        /*
        이 JavaScript 코드의 구조와 상호작용:

        1. HTML과의 상호작용:
           - document.getElementById()로 HTML 요소들을 찾아서 조작
           - addEventListener()로 HTML 요소들의 이벤트(클릭, 키보드 등) 처리
           - classList.add/remove()로 CSS 클래스 추가/제거하여 시각적 변화
           - innerHTML, textContent로 HTML 내용 동적 변경

        2. CSS와의 상호작용:
           - 'active', 'log-item', 'system', 'warning' 등의 CSS 클래스 사용
           - style 속성으로 직접 CSS 스타일 설정 (display, width, height 등)

        3. 서버와의 상호작용:
           - Socket.IO를 통해 실시간 양방향 통신
           - emit()으로 서버에 데이터 전송
           - on()으로 서버에서 오는 데이터 수신

        4. 브라우저 API 사용:
           - setTimeout/clearTimeout: 시간 지연 및 반복 작업
           - Date.now(), new Date(): 시간 정보
           - Set, Array: 데이터 저장 및 관리
           - preventDefault(): 브라우저 기본 동작 방지

        이 코드는 로봇 제어 웹 인터페이스로, 사용자의 입력(마우스, 키보드, 터치)을
        받아서 서버로 전달하고, 서버의 응답을 받아 화면에 표시하는 역할을 합니다.
        */
    </script>
</body>
</html>